iterative and recursive:
//Dont hasitate to use helperfunction in recursion
// handle start and end position in good way
// AND HANDLE ALL EDGE CAESES
// tell techniques to pass test cases if not getting sol(using print)

do with
         singly linked list , 2 way linked list
        singly circular LinkedList and two way doubly linked list

create LinkedList node 
print LinkedList
linked list input
insert node at ith position
delete node at ith position
alternate print 1, 3  ..
and 2...4


find a node in linked list
APPEND LAST N nodes TO FIRST
eleiminate duplicates from LinkedList
print reverse linked list
if linked list pelindromic

remove continuous duplicates from LinkedList
even elements and then odd elements in LinkedList
delete every nth node in LinkedLis
swap two nodes in linked list
reverese every kth element in linked list (k reverse):
Sample Input 1 :
1
1 2 3 4 5 6 7 8 9 10 -1
4
Sample Output 1 :
4 3 2 1 8 7 6 5 10 9

bubblesort LinkedList
find mid point of LinkedList
merge two sorted linked list
do merge sort on linked list
reverse linked list

Do all in iterative as well as recursive if possible
and finally builtin ll
and do question on different platforms
find middle element of linked list using fast and slow pointer concept
input and print with recursion


extras:
        make input function from 2 parameter constructor
        node * next; // or node <t>*next ;-> it is implicit no need to write explicitely
        if we remove default constructor Then we will not be able to create a node without the data
        singly linked list is uniary tree
        revise pointer reference etc
        // -1  will not be value of ll
        go with vatiation of linked list 
        // implement a gui print of data structures
        // implement slow input method of o(n^2)
         and fast one using head tail method
         //palindrome of linked list
         //length of linked list 
         cout<< NULL will print 0
         create ll in static memory and heap memory
         use stl of ll
        

